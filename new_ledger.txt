The new ledger implementation planned to solve existing problems
 - low persormance on starting up due to pulling while ledger from database
   and recalculation of hashes.
 - potencial bottlenck in ledger performance in case of huge bal (for example
   huge state of smartcontract or lstore)

So, I suggest reimplement ledger from scratch.
Therminolry:
 - bal is a storage for all data related to one particular address of chain
 - ledger is a store of all bals in chain

Ledger hash is a root hash of a merkle tree such as gb_merkle_tree where keys
is address and value is a root hash of merkle tree of bal componnets.
To solve problem of storing merkle trees in database I have rewritten
gb_merkle_tree implementation in such way it calls external function to modify
database or request data from database, also it stores accumulator and passes
it throught all modification steps (only get method does not store possible
modifications of accumulator). Thus it's possible to make modifications in
database (perform calls with side effect for example) as well as collecting 
data modification log in accumulator to store previous version of elements as 
bal snapsnot.

The ledger merkle tree will be calculated and stored only based on latest
version of bals, but bals items itself might contain older item versions.

To store bals mnesia database backed with rocksdb was chosen.
Table will store records in tuples with such structure.
{ address::binary(),
  version::integer() | latest,
  key::atom(),
  path::[binary()]|binary()|undefined,
  introduced::integer(),
  value() :: binary }.
version contains atom 'latest' for all actual records or block heigth in which
it was introduced for historical data. When replacing record previous version
must be stored as version from introduced field. On inserting new field
additional entry with version 0 must be inserted with undefined value. On
deleting just version must be replaced.
Key is a top level key of bal entity (amount, seq, t, lastblk, pubkey, state,
code, etc). Path is a top level specific further path of element.
For amount it's a currency name, for seq, t, lastblk it must be undefined, for
pubkey it's might contain key number in case of multisig or be undefined in
case of single key, for state - state's key, for lstore - path as list of 
binaries.
Garbage collector should clean up records based on introduced field, but it 
must not clean up latest fields ever. It should collect records older than
oldest requestable block. It should be at least one hour or 1000 blocks (what
is least).


To calculate actual bal hash all tuples shoud be selected with such pattern 
{Address, 'latest', _,_,_,_}.

To collect bal for particular block height (until it collected as garbage) you
shoud select all records for address and filter it for each key in such way:
take greatest version which smaller than or equal to needed block height, if 
no such record - take 'latest'.




To research:
Should merkle tree be rebalances every time or not? 

