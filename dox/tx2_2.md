# Transactions v2

Any changes you want make in the state of the blockchain can be done using transactions. There are two main types of transactions: registration transaction and generic (financial) transaction (sending money from one wallet to another).
In the future more types of transactions will be added.

## Transaction related API description

<table>
  <tr>
    <td>Url</td>
    <td>Request Type</td>
    <td>Description of parameters</td>
  </tr>
  <tr>
    <td>/api/tx/new</td>
    <td>POST</td>
    <td>Input parameters: {"tx": " ... packed and signed transaction ... "}<br>
    Response: {"txid": "153B7614F8051F79-3RGPJnQuajxy1r9zj5Jb9JUr4skE-6BC2"} - transaction identifier
    </td>
  </tr>
  <tr>
    <td>/api/tx/status/{txid}</td>
    <td>GET</td>
    <td>
      Input parameters: {txid} - transaction identifier you had from the call /api/tx/new<br>
      Response:<br>
      {"Res": null} - the transaction has not yet included into the block (no information yet)<br>
      {"Res": {"ok": true}} - the transaction has included into the block
      </td>
  </tr>
</table>


Example of sending a transaction using curl (the transaction body has been shortened):

```bash
curl http://127.0.0.1/api/tx/new -d '{"tx":"g6R0eXBlo â€¦ 2MjI4X8TfA5gc"}'
```

## Dive into transaction format


In order to make a new transaction, you should send an HTTP POST request to the server. Request data should be in JSON format and contain the key 'tx' with base64-encoded transaction container.

![transacton_v2_general](https://github.com/thepower/api_doc/blob/master/wiki/raw/transacton_v2_general.png)


The transaction container is a message pack fixmap (first byte 0x80 - 0x8f) with the following structure:


```
{
  "body": BinaryBody (binary),
  "sig": Array (array of binary),
  "ver": 2 (unsigned integer)
}
```

The keys of this fixmap should be encoded as a strings.

The value of the 'body' is a binary (0xc4 msgpack type) with msgpack encoded transaction payload (we reffering it as a transaction body).

The transaction body is a messagepack map (0xde, 0x80 - 0x8f) with one mandatory key 'k' which value indicates transaction kind and other keys depending on transaction purpose.

For best extendability transaction kind number unique for each kind with each transaction version. Headers with constants should be generated by scripts from supplied JSON file (priv/tx_const.json):

```json

{
  "purpose": {
    "0": "transfer",
    "1": "srcfee",
    "2": "dstfee",
    "3": "gas"
  },
  "kind": {
    "16": ["generic", 2],
    "17": ["register", 2],
    "18": ["deploy", 2],
    "19": ["patch", 2],
    "20": ["block", 2]
  }
}

```

The value of the 'sig' key is msgpack's array (types 0x90-0x9f or 0xdc-0xdc). Each array item contains signature for one key. Signature format (BSig) described below. Transaction might have multiple signatures.

The value of the 'ver' key is an integer, which indicates version of transaction format to specifiy which body decoder should be used. As for now it have to be 2 (0x02 in msgpack).


## The Registration Transaction

For registration of a new wallet there is the 'register' transaction type. As we mentioned before, the transaction body is message pack map (or fixmap) type. The first byte of this type is the 0xDE or from a range 0x80-0x8F.

![transacton_v2_registration](https://github.com/thepower/api_doc/blob/master/wiki/raw/transacton_v2_registration.png)

Here is an example of registration transaction body content (shown as json, binary data represented as base64-encoded strings):

```json
{
  "k": 0x11,
  "t": 1530106891372
  "nonce": "T1umkWY=",
  "h": "Y6dVG5CvZacwlbf21oybiIHh/4h+8d2EJwF7Qp/GpCA=",
  "e": {}
}
```

The value of the 'k' key should always be 0x11 for registration transactions (msgpack positive fixint type, 0x11).

The value of the 't' key is a transaction creation timestamp (unixtime in milliseconds, msgpack uint 64 type, 0xcf).

The value of the 'nonce' key can be any type and should be used to change of the transaction hash (see comment about difficulty below).

The value of the 'h' key is sha256 hash of concatenated public keys sorted ascending (msgpack binary type, 0xc4).

The value of the 'e' key is user defined extra data included into transaction (msgpack map or fixmap type, 0xde, 0x80-0x8f).

### Example of calculating the value of the 'h' key.

Let's take 3 arbitrary public keys (shown as json array, binary data encoded as hexstring):

```json
[
  "025348F9AD2BDC8E394B7C3C69FDD221F8C7F95B458D56AACD677C4C9ABF8E1AE7",
  "0234326DF0BDF60DA3E6D203B73C0D0C4DEE518BD60717C3B20C0D27812C7DADEB",
  "02266C9DAA52F9BB5AD73B77A703437E27A3344F36F1D4FF0C0267C3DEA2BC91D7"
]
```

Please note, keys should be represented as binary data (i.e. for string 02 you should take 0x02 byte of binary data).

After sorting the keys we'll get the following order:


```json
[
  "02266C9DAA52F9BB5AD73B77A703437E27A3344F36F1D4FF0C0267C3DEA2BC91D7",
  "0234326DF0BDF60DA3E6D203B73C0D0C4DEE518BD60717C3B20C0D27812C7DADEB",
  "025348F9AD2BDC8E394B7C3C69FDD221F8C7F95B458D56AACD677C4C9ABF8E1AE7"
]
```

After concatination step we'll get the following data:

```
02266C9DAA52F9BB5AD73B77A703437E27A3344F36F1D4FF0C0267C3DEA2BC91D70234326DF0BDF60DA3E6D203B73C0D0C4DEE518BD60717C3B20C0D27812C7DADEB025348F9AD2BDC8E394B7C3C69FDD221F8C7F95B458D56AACD677C4C9ABF8E1AE7
```

The next step is calculating of the sha256 hash of this data. Please note, we should deal with binary data (i.e. string E7 in the example should be byte 0xE7 of binary data). We calculate hash of binary data, NOT the string of ASCII symbols.

For the data in this example the sha256 hash is `CB32960606B0E3846D763B8DA8FE5EF7379D89A227C2B6DBDA499F4ECEA0B071`.

### PoW difficulty of the registration transaction

In order to prevent mass wallets registration we require a PoW calculation for every registration transaction. In our case the PoW means you should change the transaction data to get a sha256 hash which meets special requirements. This requirements usually called difficulty.

You can get current difficulty of the shard by API call (GET) /api/settings. By this API call you'll get an JSON object. The value of the key settings.current.register.diff is the difficulty of this shard.

For example, if difficulty was 16 you should get a sha265 hash of the transaction with 16 leading bits of 0 (i.e. two leading bytes should be equal to 0). You should change the value of the 'nonce' key of the registration transaction to get a hash with 16 leading 0 bits.

Please note, the hash of the transaction body doesn't put in the transaction itself. In order to check is transaction meets the difficulty requirements or not server recalculate the sha256 hash of the transaction body. As mentioned before, you should change the value of the 'nonce' key to get the transaction data with sha256 hash containing 'difficulty' of leading bits equal to 0.

## BSig container and signature format

The BSig container is a binary data of TLV format (Tag - Length - Value).

![bsig](https://github.com/thepower/api_doc/blob/master/wiki/raw/bsig.png)

Each signature may contain additional data, which is signed with main payload (body, data for sign).

Here is predefined fields.

| name           | length | tag | type   |
|----------------|--------|-----|--------|
| timestamp      | 8      | 1   | uint64 |
| pubkey         | vary   | 2   | binary |
| createduration | 8      | 3   | uint64 |
| OTHER          | vary   | 240 | binary |
| purpose        | vary   | 254 | string |
| signature      | vary   | 255 | binary |

Public key is mandatory. Every BSig should contain public key tag.

Let's look at the signing procedure by an example.

Let's we have the private key `0102030405060708090001020304050607080900010203040506070809000102` and we want to sign the string "Hello, world!".

First of all we need to calculate public key, for this private key it'd be `02B1912FABA80FCECD2A64C574FEFE422C61106001EC588AF1BD9D7548B81064CB`.

Also we put the current timestamp in container.

Here is the binary data we have at this step:

```
02 21 02B1912FABA80FCECD2A64C574FEFE422C61106001EC588AF1BD9D7548B81064CB
01 08 00000164B250D800
```

```
tag 0x02 (public key), length of data 0x21, public key data
tag 0x01 (timestamp), length of data 0x08, current unixtime as microseconds in unsigned int 64 format
```

The next step is appending of data for signing to binary from the previous step.

```
02 21 02B1912FABA80FCECD2A64C574FEFE422C61106001EC588AF1BD9D7548B81064CB
01 08 00000164B250D800 48656C6C6F2C20776F726C6421
```

The sha256 hash of this whole binary will be `60C3B88A5F32816F574C8FABFB45A35338A20D7C1678F20DABDBBD7F94568F15`.

At the next step we calculate signature of the hash from the previous step. The signature is

```
304402205250D827749F285CE174137EC88B394092E43B9E6C6774045EE5E6ED502322520
2204D1628F019E57BF19C1A0FE37193355A059F22CF8203D85E112FF3B4873D46FE
```

Please note, we always deals with binary data. You should sign the binary data of hash (NOT it's ASCII characters representation).

At the next step we should remove the payload which we appended to container and prepend the container with the signature tag.

```
FF 46 304402205250D827749F285CE174137EC88B394092E43B9E6C6774045EE5E6ED5023225202204D1628F019E57BF19C1A0FE37193355A059F22CF8203D85E112FF3B4873D46FE
02 21 02B1912FABA80FCECD2A64C574FEFE422C61106001EC588AF1BD9D7548B81064CB
01 08 00000164B250D800
```

```
tag 0xFF (signature), length of data 0x46, binary data of signature (NOT it's ASCII)
tag 0x02 (public key), length of data 0x21, binary data of public key (NOT it's ASCII)
tag 0x01 (timestamp), length of data 0x08, current unixtime as microseconds in unsigned int 64 format
```







