Новый механизм синхронизации будет работать следующим образом:

 - нода стартует, через discovery подключается куда надо, затем через
   TPIC она бродкастом спрашивает у всех blockchain процессов, кто готов
   отдать ей синхронизацию
   call(<<"blockchain">>, #{null=><<"sync_request">>})

 - Нода получает один или несколько ответов,
    #{null:=<<"sync_available">> - означает что нода готова отдавать синк, иначе
                                с нее синхронизироваться нельзя
    chain:=Chain, - в каком она чейне
    last_hash:=Hash, - хэш последнего блока чейна
    last_height:=Height - высота ее чейна
    byblock=>true,  - доступна синхронизация поблочная
    instant=>true   - доступна синзронизация instant
    }

  Далее нужно понять на сколько мы отсали от сети и выбрать подходящий метод
  синхронизации, который поддерживается пирами (block by block или instant).
  При маленьком отставании block by block использовать рациональнеею

 - block by block 
    Нода запрашивает от выбранного пира нужный блок, его предка или потомка
    Блок задается в hash а в rel задается один из трех вариантов: self, prev,
    child.

    call(Handler,
        #{null=><<"pick_block">>, <<"hash">>=>Hash, <<"rel">>=>prev},
    ),

    В ответ приходит 
    #{
        null=><<"block">>,
        req=>#{<<"hash">>=>Hash, <<"rel">>=>MyRel} - тут будет повторен запрос
    }
    При ошибке так же будет передано поле <<"error">>, которое может принимать 
    значения:
             * #{ error=>noblock } - на ноде нет блока с таким хэшем (может
               быть есть на других)
             * #{ error=>nochild } - у блока еще нет child (скорее всего он
               последний)
             * #{ error=>noprev } - нет parent (наверное это genesis)
             * #{ error => unknown } - другая ошибка

    В случае успешного выполнения в ответе поля error не будет, а будет поле 
    block в котором будет бинаризированный блок (его надо распаковать с
    помощью block:unpack/1)
    Далее операцию можно повторить до нужной синхронизации

 - instant
 Instant синхронизация присылает нам текущий блок (на момент окончания
 синхронизации он может оказаться не последний, поэтому далее надо
 синхронизироваться block by block) и состояние его ledgerа и settingsов.
 Ledger и Settings необходимо проверять по данным из блока, а сам блок
 необходимо проверять на валидность и доверенность ключей, его подписавших.

 Отправляем сообщение 
        #{null=><<"instant_sync_run">>}
 В ответ прилетает блок #{<<"block">>:=BinBlock}, который нужно распаковать
 block:unpack/1, затем для получения ledgerа нужно делать call с сообщением
 #{null=><<"continue">>}, при этом в ответ будут приходить сообщения 
 #{<<"done">>:=true|false, <<"ledger">>:=list()}. Синхронизацию следует 
 продолжать до тех пор, пока done не станет true.
 Синхронизацию можно прервать досрочно отправив #{null=><<"stop">>}.
 Синхронизатор на ноде-отправителе автоматически завершается, если в течении
 некоторого времени (обычно 30 сек) нет запросов и удаляет снэпшот. При этом,
 если синхронизация не завершена - ее придется начать с начала.

example in tpnode/src/test_sync.erl

